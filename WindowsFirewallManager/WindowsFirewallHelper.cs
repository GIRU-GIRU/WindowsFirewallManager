using NetFwTypeLib;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace FirewallManager
{
    public enum FirewallProfiles
    {
        Domain = 1,
        Private = 2,
        Public = 4
    }

    enum Protocol
    {
        NET_FW_IP_PROTOCOL_TCP = 6,
        NET_FW_IP_PROTOCOL_UDP = 17,
        NET_FW_IP_PROTOCOL_ANY = 256
    }


    static internal class WindowsFirewallHelper
    {
        private const string _firewallPolicyTypeName = "HNetCfg.FwPolicy2";
        private const string _firewallRuleTypeName = "HNetCfg.FwRule";
        private const string _ruleDescription = ">>>> Generated by FirewallManager <<<<";
        internal static INetFwPolicy2 CreatePolicy() => Activator.CreateInstance(Type.GetTypeFromProgID(_firewallPolicyTypeName)) as INetFwPolicy2;
        internal static void CheckToRemoveExistingRules(this INetFwPolicy2 firewallPolicy, string applicationPath)
        {
            List<INetFwRule> firewallRules = firewallPolicy.Rules.OfType<INetFwRule>().ToList();

            var existingRules = firewallRules.WhereApplicationName(applicationPath);

            if (existingRules.Count() > 0)
            {
                foreach (var item in existingRules)
                {
                    firewallPolicy.Rules.Remove(item.Name);
                }

                Console.WriteLine($"Removed {existingRules.Count()} existing rules for {applicationPath}");

            }
            else
            {
                Console.WriteLine($"No existing none-wfm rules for {applicationPath}");
            }
        }

        internal static void RemoveExistingGeneratedRules(this INetFwPolicy2 policy)
        {
            var existingRules = policy.Rules.OfType<INetFwRule2>().Where(x => x.Description == _ruleDescription);

            if (existingRules.Count() > 0)
            {
                int count = existingRules.Count();

                foreach (var rules in existingRules)
                {
                    policy.Rules.Remove(rules.Name);
                }

                Console.WriteLine($"Removed {count} generated rules");
            }
            else
            {
                Console.WriteLine($"No existing generated rules were found");
            }
        }

        internal static void CreateAllowingRules(this INetFwPolicy2 policy, string applicationPath)
        {
            if (File.Exists(applicationPath))
            {
                policy.Rules.Add(CreateRule(applicationPath, false, true));
                policy.Rules.Add(CreateRule(applicationPath, false, false));

                Console.WriteLine($"Created allow rules for {Path.GetFileName(applicationPath)}");
            }
            else
            {
                Console.WriteLine($"Invalid path - {applicationPath}, skipping");
            }
        }

        internal static void CreateBlockingRules(this INetFwPolicy2 policy, string applicationPath)
        {
            if (File.Exists(applicationPath))
            {
                policy.Rules.Add(CreateRule(applicationPath, true, true));
                policy.Rules.Add(CreateRule(applicationPath, true, false));

                Console.WriteLine($"Created blocking rules for {Path.GetFileName(applicationPath)}");
            }
            else
            {
                Console.WriteLine($"Invalid path - {applicationPath}, skipping");
            }
        }

        private static INetFwRule2 CreateRule(string applicationPath, bool blocking, bool outbound)
        {
            INetFwRule2 rule = Activator.CreateInstance(Type.GetTypeFromProgID(_firewallRuleTypeName)) as INetFwRule2;
            string fileName = Path.ChangeExtension(Path.GetFileName(applicationPath), null);

            string ruleName = $"!{fileName}{(blocking ? "Block" : "Allow")}{(outbound ? "Out" : "In")}";

            rule.Enabled = true;
            rule.Action = blocking ? NET_FW_ACTION_.NET_FW_ACTION_BLOCK : NET_FW_ACTION_.NET_FW_ACTION_ALLOW;
            rule.ApplicationName = applicationPath;
            rule.Direction = outbound ? NET_FW_RULE_DIRECTION_.NET_FW_RULE_DIR_OUT : NET_FW_RULE_DIRECTION_.NET_FW_RULE_DIR_IN;
            rule.Protocol = (int)Protocol.NET_FW_IP_PROTOCOL_ANY;
            rule.Name = ruleName;
            rule.Description = _ruleDescription;
            rule.Profiles = (int)(FirewallProfiles.Private | FirewallProfiles.Public);

            return rule;

        }

    }
}
